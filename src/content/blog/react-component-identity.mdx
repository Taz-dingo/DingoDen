---
title: "React 组件的“身份”之谜：为什么你的状态会无故消失？"
description: "深入探讨 React 中一个常见的陷阱：在父组件内部定义子组件，以及它为何会导致状态重置和性能问题。"
pubDate: "Jul 30 2025"
---

import Note from '../../components/Note.astro';
import BadExample from '../../components/BadExample.jsx';
import GoodExample from '../../components/GoodExample.jsx';

在 React 中，组件的“身份”是其核心协调机制的一部分。React 通过判断两次渲染之间，某个位置的组件类型是否为同一个，来决定是更新现有实例还是销毁并重建一个。

这个“身份”通常就是组件函数的**引用**。如果引用变了，React 会认为这是一个全新的组件。

### 错误示范：在父组件内部定义组件

下面是一个可交互的例子。请先点击几次子组件的按钮增加计数，然后再点击父组件的按钮，观察计数器如何被重置为 0。

<BadExample client:load />

<Note title="根本原因">
每当父组件重新渲染，`const Counter = () => { ... }` 这段代码都会被**重新执行**，从而在内存中创建一个**全新的 `Counter` 函数**。React 认为这是一个全新的组件类型，因此会卸载旧实例（销毁其 state），并挂载一个新实例。
</Note>

### 正确姿势：在外部定义组件

现在，我们把 `Counter` 组件的定义移到父组件的外部。在这个例子中，无论你点击多少次父组件的更新按钮，子组件的状态都会被完美保留。

<GoodExample client:load />

<Note title="为什么这样可行？">
因为 `Counter` 函数的定义在外部，它的引用是稳定不变的。无论父组件重新渲染多少次，React 都知道这是同一个组件，因此会正确地保留其状态并只在必要时更新它。
</Note>

### 结论

**永远不要在组件的渲染函数体内定义新的组件。** 这不仅会导致 state 丢失，还会引起不必要的卸载和挂载，造成性能问题。请始终在模块的顶层作用域定义你的组件。
