---
title: "React Pitfall：为什么你的状态会无故消失？"
description: "深入探讨 React 中一个常见的陷阱：在父组件内部定义子组件，以及它为何会导致状态重置和性能问题。"
pubDate: "Jul 30 2025"
---

import Note from "@/components/common/Note.astro";
import BadExample from "./BadExample.jsx";
import GoodExample from "./GoodExample.jsx";

在 React 中，组件的“身份”是其核心协调机制的一部分。React 通过判断两次渲染之间，某个位置的组件类型是否为同一个，来决定是更新现有实例还是销毁并重建一个。

这个“身份”通常就是组件函数的**引用**。如果引用变了，React 会认为这是一个全新的组件。

### 错误示范：在父组件内部定义组件定义组件定义组件定义组件定义组件定义组件

下面是一个可交互的例子。请先点击几次子组件的按钮增加计数，然后再点击父组件的按钮，观察计数器如何被重置为 0。

<BadExample client:load />

<Note title="根本原因">
每当父组件重新渲染，`const Counter = () => { ... }` 这段代码都会被**重新执行**，从而在内存中创建一个**全新的 `Counter` 函数**。React 认为这是一个全新的组件类型，因此会卸载旧实例（销毁其 state），并挂载一个新实例。
</Note>

### 正确姿势：在外部定义组件

现在，我们把 `Counter` 组件的定义移到父组件的外部。在这个例子中，无论你点击多少次父组件的更新按钮，子组件的状态都会被完美保留。

<GoodExample client:load />

<Note title="为什么这样可行？">
  因为 `Counter`
  函数的定义在外部，它的引用是稳定不变的。无论父组件重新渲染多少次，React
  都知道这是同一个组件，因此会正确地保留其状态并只在必要时更新它。
</Note>

### 结论

**永远不要在组件的渲染函数体内定义新的组件。** 这不仅会导致 state 丢失，还会引起不必要的卸载和挂载，造成性能问题。请始终在模块的顶层作用域定义你的组件。
